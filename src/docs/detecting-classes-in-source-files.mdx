import { TipGood, TipBad, TipInfo } from "@/components/tips";
import { Iframe } from "@/components/iframe";
import { Example } from "@/components/example";
import { Figure } from "@/components/figure";
import { CodeExampleStack } from "@/components/code-example";

export const title = "Обнаружение классов в исходных файлах";
export const description = "Понимание и настройка того, как Tailwind сканирует ваши исходные файлы.";

## Обзор

Tailwind работает путем сканирования вашего проекта на предмет утилитарных классов, а затем генерирует весь необходимый CSS на основе классов, которые вы фактически использовали.

Это гарантирует, что ваш CSS будет максимально маленьким, а также делает возможными такие функции, как [произвольные значения](/docs/adding-custom-styles#using-arbitrary-values).

### Как обнаруживаются классы

Tailwind обрабатывает все ваши исходные файлы как обычный текст и не пытается анализировать ваши файлы как код каким-либо образом.

Вместо этого он просто ищет любые токены в вашем файле, которые могут быть классами, основываясь на том, какие символы Tailwind ожидает в именах классов:

```jsx
// [!code filename:JSX]
// [!code word:bg-blue-500]
// [!code word:rounded-full]
// [!code word:text-white]
// [!code word:text-black]
// [!code word:font-medium]
// [!code word:text-sm\/6]
// [!code word:font-sans]
// [!code word:bg-black]
// [!code word:bg-white]
// [!code word:className]
// [!code word:function]
// [!code word:children]
// [!code word:button]
// [!code word:shadow]
// [!code word:export]
// [!code word:colors]
// [!code word:color]
// [!code word:black]
// [!code word:white]
// [!code word:const]
// [!code word:blue]
// [!code word:return]
// [!code word:py-1.5]
// [!code word:px-2]
export function Button({ color, children }) {
  const colors = {
    black: "bg-black text-white",
    blue: "bg-blue-500 text-white",
    white: "bg-white text-black",
  };

  return (
    <button className={`${colors[color]} rounded-full px-2 py-1.5 font-sans text-sm/6 font-medium shadow`}>
      {children}
    </button>
  );
}
```

Затем он пытается сгенерировать CSS для всех этих токенов, отбрасывая любые токены, которые не соответствуют утилитарному классу, о котором знает фреймворк.

### Динамические имена классов

Поскольку Tailwind сканирует ваши исходные файлы как обычный текст, он не может понять конкатенацию строк или интерполяцию в языке программирования, который вы используете.

<TipBad>{<>Не конструируйте имена классов динамически</>}</TipBad>

```html
<!-- [!code filename:HTML] -->
<div class="text-{{ error ? 'red' : 'green' }}-600"></div>
```

В приведенном выше примере строки `text-red-600` и `text-green-600` не существуют, поэтому Tailwind не сгенерирует эти классы.

Вместо этого убедитесь, что любые имена классов, которые вы используете, существуют полностью:

<TipGood>{<>Всегда используйте полные имена классов</>}</TipGood>

```html
<!-- [!code filename:HTML] -->
<!-- [!code word:text-red-600] -->
<!-- [!code word:text-green-600] -->
<div class="{{ error ? 'text-red-600' : 'text-green-600' }}"></div>
```

Если вы используете библиотеку компонентов, такую как React или Vue, это означает, что вы не должны использовать пропсы для динамического конструирования классов:

<TipBad>Не используйте пропсы для динамического построения имен классов</TipBad>

```jsx
// [!code filename:JSX]
function Button({ color, children }) {
  return <button className={`bg-${color}-600 hover:bg-${color}-500 ...`}>{children}</button>;
}
```

Вместо этого сопоставьте пропсы с полными именами классов, которые статически обнаруживаются во время сборки:

<TipGood>Всегда сопоставляйте пропсы со статическими именами классов</TipGood>

```jsx
// [!code filename:JSX]
function Button({ color, children }) {
  const colorVariants = {
    blue: "bg-blue-600 hover:bg-blue-500",
    red: "bg-red-600 hover:bg-red-500",
  };

  return <button className={`${colorVariants[color]} ...`}>{children}</button>;
}
```

Это имеет дополнительное преимущество, позволяя вам сопоставлять разные значения пропсов с разными оттенками цветов, например:

```jsx
// [!code filename:JSX]
function Button({ color, children }) {
  const colorVariants = {
    blue: "bg-blue-600 hover:bg-blue-500 text-white",
    red: "bg-red-500 hover:bg-red-400 text-white",
    yellow: "bg-yellow-300 hover:bg-yellow-400 text-black",
  };

  return <button className={`${colorVariants[color]} ...`}>{children}</button>;
}
```

Пока вы всегда используете полные имена классов в своем коде, Tailwind будет генерировать весь ваш CSS идеально каждый раз.

### Какие файлы сканируются

Tailwind будет сканировать каждый файл в вашем проекте на предмет имен классов, за исключением следующих случаев:

- Файлы, которые находятся в вашем файле `.gitignore`
- Бинарные файлы, такие как изображения, видео или zip-файлы
- CSS файлы
- Общие файлы блокировки менеджеров пакетов

Если вам нужно сканировать любые файлы, которые Tailwind игнорирует по умолчанию, вы можете [явно зарегистрировать](#explicitly-registering-sources) эти источники.

## Явная регистрация источников

Используйте `@source` для явной регистрации путей к источникам относительно таблицы стилей:

```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source "../node_modules/@acmecorp/ui-lib";
```

Это особенно полезно, когда вам нужно сканировать внешнюю библиотеку, которая построена с Tailwind, поскольку зависимости обычно перечислены в вашем файле `.gitignore` и игнорируются Tailwind по умолчанию.

### Установка базового пути

Tailwind использует текущую рабочую директорию как отправную точку при сканировании имен классов по умолчанию.

Чтобы явно установить базовый путь для обнаружения источников, используйте функцию `source()` при импорте Tailwind в ваш CSS:

```css
/* [!code filename:CSS] */
/* [!code word:source("../src")] */
@import "tailwindcss" source("../src");
```

Это может быть полезно при работе с монорепозиториями, где ваши команды сборки запускаются из корня монорепозитория вместо корня каждого проекта.

### Игнорирование конкретных путей

Используйте `@source not` для игнорирования конкретных путей, относительно таблицы стилей, при сканировании имен классов:

```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source not "../src/components/legacy";
```

Это полезно, когда у вас есть большие директории в вашем проекте, которые, как вы знаете, не используют классы Tailwind, такие как устаревшие компоненты или сторонние библиотеки.

### Отключение автоматического обнаружения

Используйте `source(none)` для полного отключения автоматического обнаружения источников, если вы хотите явно зарегистрировать все ваши источники:

```css
/* [!code filename:CSS] */
/* [!code word:source("../src")] */
@import "tailwindcss" source(none);

@source "../admin";
@source "../shared";
```

Это может быть полезно в проектах, которые имеют несколько таблиц стилей Tailwind, где вы хотите убедиться, что каждая из них включает только те классы, которые нужны каждой таблице стилей.

## Безопасный список конкретных утилит

Если вам нужно убедиться, что Tailwind генерирует определенные имена классов, которых нет в ваших файлах контента, используйте `@source inline()` для принудительной их генерации:

<CodeExampleStack>
```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source inline("underline");
```

```css
/* [!code filename:Generated CSS] */
.underline {
  text-decoration: underline;
}
```

</CodeExampleStack>

### Безопасный список вариантов

Вы также можете использовать `@source inline()` для генерации классов с вариантами. Например, чтобы сгенерировать класс `underline` с вариантами hover и focus, добавьте `{hover:,focus:,}` к входному источнику:

<CodeExampleStack>
```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source inline("{hover:,focus:,}underline");
```

```css
/* [!code filename:Generated CSS] */
.underline {
  text-decoration: underline;
}
@media (hover: hover) {
  .hover\:underline:hover {
    text-decoration: underline;
  }
}
@media (focus: focus) {
  .focus\:underline:focus {
    text-decoration: underline;
  }
}
```

</CodeExampleStack>

### Безопасный список с диапазонами

Входной источник [расширяется фигурными скобками](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html), поэтому вы можете генерировать несколько классов одновременно. Например, чтобы сгенерировать все красные цвета фона с вариантами hover, используйте диапазон:

<CodeExampleStack>
```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source inline("{hover:,}bg-red-{50,{100..900..100},950}");
```

```css
/* [!code filename:Generated CSS] */
.bg-red-50 {
  background-color: var(--color-red-50);
}
.bg-red-100 {
  background-color: var(--color-red-100);
}
.bg-red-200 {
  background-color: var(--color-red-200);
}

/* ... */

.bg-red-800 {
  background-color: var(--color-red-800);
}
.bg-red-900 {
  background-color: var(--color-red-900);
}
.bg-red-950 {
  background-color: var(--color-red-950);
}
@media (hover: hover) {
  .hover\:bg-red-50:hover {
    background-color: var(--color-red-50);
  }

  /* ... */

  .hover\:bg-red-950:hover {
    background-color: var(--color-red-950);
  }
}
```

</CodeExampleStack>

Это генерирует красные цвета фона от 100 до 900 с шагом 100, а также первые и последние оттенки 50 и 950. Это также добавляет вариант `hover:` для каждого из этих классов.

### Явное исключение классов

Используйте `@source not inline()` для предотвращения генерации конкретных классов, даже если они обнаружены в ваших исходных файлах:

```css
/* [!code filename:CSS] */
@import "tailwindcss";
/* [!code highlight:2] */
@source not inline("{hover:,focus:,}bg-red-{50,{100..900..100},950}");
```

Это явно исключит красные утилиты фона вместе с их вариантами hover и focus из генерации.
