import { Example } from "@/components/example";
import { CodeExampleWrapper, CodeExampleStack } from "@/components/code-example";
import { Iframe } from "@/components/iframe.tsx";
import { Figure } from "@/components/figure";
import { TipGood, TipBad, TipCompat, TipInfo } from "@/components/tips";
import { MultiCursorAnimation, MultiCursorPreview } from "@/components/multi-cursor/animation.tsx";
import { MultiCursorCode } from "@/components/multi-cursor/example.tsx";
import erinLindford from "./img/erin-lindford.jpg";

export const title = "Стилизация с помощью утилитарных классов";
export const description = "Создание сложных компонентов из ограниченного набора примитивных утилит.";

## Обзор

Вы стилизуете элементы с помощью Tailwind, комбинируя множество узкоспециализированных классов для оформления _(классы утилит)_ непосредственно в разметке:

<Figure>

<Example>
  {
    <div className="mx-auto flex max-w-sm items-center gap-x-4 rounded-xl bg-white p-6 shadow-lg outline outline-black/5 dark:bg-slate-800 dark:shadow-none dark:-outline-offset-1 dark:outline-white/10">
      <svg className="size-12 shrink-0" viewBox="0 0 40 40">
        <defs>
          <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
            <stop stopColor="#2397B3" offset="0%"></stop>
            <stop stopColor="#13577E" offset="100%"></stop>
          </linearGradient>
          <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
            <stop stopColor="#73DFF2" offset="0%"></stop>
            <stop stopColor="#47B1EB" offset="100%"></stop>
          </linearGradient>
        </defs>
        <g fill="none" fillRule="evenodd">
          <path
            d="M28.872 22.096c.084.622.128 1.258.128 1.904 0 7.732-6.268 14-14 14-2.176 0-4.236-.496-6.073-1.382l-6.022 2.007c-1.564.521-3.051-.966-2.53-2.53l2.007-6.022A13.944 13.944 0 0 1 1 24c0-7.331 5.635-13.346 12.81-13.95A9.967 9.967 0 0 0 13 14c0 5.523 4.477 10 10 10a9.955 9.955 0 0 0 5.872-1.904z"
            fill="url(#a)"
            transform="translate(1 1)"
          ></path>
          <path
            d="M35.618 20.073l2.007 6.022c.521 1.564-.966 3.051-2.53 2.53l-6.022-2.007A13.944 13.944 0 0 1 23 28c-7.732 0-14-6.268-14-14S15.268 0 23 0s14 6.268 14 14c0 2.176-.496 4.236-1.382 6.073z"
            fill="url(#b)"
            transform="translate(1 1)"
          ></path>
          <path
            d="M18 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4zM24 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4zM30 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"
            fill="#FFF"
          ></path>
        </g>
      </svg>
      <div>
        <div className="text-xl font-medium text-black dark:text-white">ChitChat</div>
        <p className="text-gray-500 dark:text-gray-400">У вас есть новое сообщение!</p>
      </div>
    </div>
  }
</Example>

```html
<!-- prettier-ignore -->
<div class="mx-auto flex max-w-sm items-center gap-x-4 rounded-xl bg-white p-6 shadow-lg outline outline-black/5 dark:bg-slate-800 dark:shadow-none dark:-outline-offset-1 dark:outline-white/10">
  <img class="size-12 shrink-0" src="/img/logo.svg" alt="ChitChat лого" />
  <div>
    <div class="text-xl font-medium text-black dark:text-white">ChitChat</div>
    <p class="text-gray-500 dark:text-gray-400">У вас есть новое сообщение!</p>
  </div>
</div>
```

</Figure>

Например, в приведенном выше интерфейсе мы использовали:

- Утилиты [display](/docs/display#flex) и [padding](/docs/padding) (`flex`, `shrink-0` и `p-6`) для управления общей компоновкой
- Утилиты [max-width](/docs/max-width) и [margin](/docs/margin) (`max-w-sm` и `mx-auto`) для ограничения ширины карточки и центрирования ее по горизонтали
- Утилиты [background-color](/docs/background-color), [border-radius](/docs/border-radius) и [box-shadow](/docs/box-shadow) (`bg-white`, `rounded-xl` и `shadow-lg`) для стилизации внешнего вида карточки
- Утилиты [width](/docs/width) и [height](/docs/height) (`size-12`) для установки ширины и высоты логотипа
- Утилиты [gap](/docs/gap) (`gap-x-4`) для управления расстоянием между логотипом и текстом
- Утилиты [font-size](/docs/font-size), [color](/docs/text-color) и [font-weight](/docs/font-weight) (`text-xl`, `text-black`, `font-medium` и т.д.) для стилизации текста карточки

Стилизация таким образом противоречит многим традиционным лучшим практикам, но как только вы попробуете, вы быстро заметите несколько действительно важных преимуществ:

- **Вы делаете вещи быстрее** — вы не тратите время на придумывание имен классов, принятие решений о селекторах или переключение между HTML и CSS файлами, поэтому ваши дизайны собираются очень быстро.
- **Внесение изменений кажется безопаснее** — добавление или удаление утилитарного класса к элементу влияет только на этот элемент, поэтому вам никогда не нужно беспокоиться о случайном нарушении чего-то на другой странице, использующей тот же CSS.
- **Поддержка старых проектов становится проще** — изменение чего-то означает просто нахождение этого элемента в вашем проекте и изменение классов, а не попытку вспомнить, как работает весь этот пользовательский CSS, который вы не трогали шесть месяцев.
- **Ваш код становится более портативным** — поскольку структура и стилизация находятся в одном месте, вы можете легко копировать и вставлять целые фрагменты интерфейса, даже между разными проектами.
- **Ваш CSS перестает расти** — поскольку утилитарные классы настолько многоразовые, ваш CSS не продолжает расти линейно с каждой новой функцией, которую вы добавляете в проект.

Эти преимущества имеют большое значение для небольших проектов, но они еще более ценны для команд, работающих над долгосрочными проектами в масштабе.

### Почему бы просто не использовать встроенные стили?

Обычная реакция на этот подход — задаться вопросом: «разве это не просто встроенные стили?» и в некотором смысле это так — вы применяете стили непосредственно к элементам, вместо того чтобы назначать им имя класса и затем стилизовать этот класс.

Но использование утилитарных классов имеет много важных преимуществ перед встроенными стилями, например:

- **Дизайн с ограничениями** — используя встроенные стили, каждое значение является магическим числом. С утилитами вы выбираете стили из [предопределенной системы дизайна](/docs/theme), что делает создание визуально согласованных интерфейсов намного проще.
- **Состояния наведения, фокуса и другие** — встроенные стили не могут нацеливаться на состояния, такие как наведение или фокус, но [варианты состояний](/docs/hover-focus-and-other-states) Tailwind позволяют легко стилизовать эти состояния с помощью утилитарных классов.
- **Медиа-запросы** — вы не можете использовать медиа-запросы во встроенных стилях, но вы можете использовать [адаптивные варианты](/docs/responsive-design) Tailwind для легкого создания полностью адаптивных интерфейсов.

Этот компонент полностью адаптивен и включает кнопку со стилями наведения и активного состояния, и построен полностью с помощью утилитарных классов:

<Figure>

<Example resizable>
  {
    <div className="mx-auto max-w-sm space-y-2 rounded-xl bg-white px-8 py-8 shadow-lg ring ring-black/5 @sm:flex @sm:items-center @sm:space-y-0 @sm:gap-x-6 @sm:py-4">
      <img
        className="mx-auto block h-24 rounded-full @sm:mx-0 @sm:shrink-0"
        src={erinLindford.src}
        alt="Лицо женщины"
      />
      <div className="space-y-2 text-center @sm:text-left">
        <div className="space-y-0.5">
          <p className="text-lg font-semibold text-black">Эрин Линдфорд</p>
          <p className="font-medium text-gray-500">Инженер продукта</p>
        </div>
        <button className="rounded-full border border-purple-200 px-4 py-1 text-sm font-semibold text-purple-600 hover:border-transparent hover:bg-purple-600 hover:text-white active:bg-purple-700">
          Сообщение
        </button>
      </div>
    </div>
  }
</Example>

```html
<!-- [!code classes:sm:flex-row,sm:py-4,sm:gap-6,sm:mx-0,sm:shrink-0,sm:text-left,sm:items-center] -->
<!-- [!code classes:hover:text-white,hover:bg-purple-600,hover:border-transparent,active:bg-purple-700] -->
<div class="flex flex-col gap-2 p-8 sm:flex-row sm:items-center sm:gap-6 sm:py-4 ...">
  <img class="mx-auto block h-24 rounded-full sm:mx-0 sm:shrink-0" src="/img/erin-lindford.jpg" alt="" />
  <div class="space-y-2 text-center sm:text-left">
    <div class="space-y-0.5">
      <p class="text-lg font-semibold text-black">Эрин Линдфорд</p>
      <p class="font-medium text-gray-500">Инженер продукта</p>
    </div>
    <!-- prettier-ignore -->
    <button class="border-purple-200 text-purple-600 hover:border-transparent hover:bg-purple-600 hover:text-white active:bg-purple-700 ...">
      Сообщение
    </button>
  </div>
</div>
```

</Figure>

## Мыслить в утилитарных классах

### Стилизация состояний наведения и фокуса

Чтобы стилизовать элемент в состояниях, таких как наведение или фокус, добавьте префикс к любой утилите с состоянием, которое вы хотите нацелить, например `hover:bg-sky-700`:

<Figure hint="Наведите курсор на эту кнопку, чтобы увидеть изменение цвета фона">

<Example>
  {
    <div className="grid place-items-center">
      <button className="rounded-full bg-sky-500 px-5 py-2 text-sm leading-5 font-semibold text-white hover:bg-sky-700">
        Сохранить изменения
      </button>
    </div>
  }
</Example>

```html
<!-- [!code word:hover\:bg-sky-700] -->
<button class="bg-sky-500 hover:bg-sky-700 ...">Сохранить изменения</button>
```

</Figure>

Эти префиксы называются [вариантами](/docs/hover-focus-and-other-states) в Tailwind, и они применяют стили из утилитарного класса только тогда, когда условие для этого варианта совпадает.

Вот как выглядит сгенерированный CSS для класса `hover:bg-sky-700`:

```css
/* [!code filename: Generated CSS] */
.hover\:bg-sky-700 {
  &:hover {
    background-color: var(--color-sky-700);
  }
}
```

Обратите внимание, что этот класс ничего не делает, _если_ элемент не наведен? Его _единственная_ задача — предоставить стили наведения — ничего больше.

Это отличается от того, как вы бы писали традиционный CSS, где один класс обычно предоставляет стили для многих состояний:

```html
/* [!code filename:HTML] */
<button class="btn">Сохранить изменения</button>

<style>
  .btn {
    background-color: var(--color-sky-500);
    &:hover {
      background-color: var(--color-sky-700);
    }
  }
</style>
```

Вы даже можете комбинировать варианты в Tailwind, чтобы применить утилиту, когда совпадают несколько условий, например, сочетая `hover:` и `disabled:`:

```html
<!-- [!code classes:disabled:hover:bg-sky-500] -->
<button class="bg-sky-500 disabled:hover:bg-sky-500 ...">Сохранить изменения</button>
```

Узнайте больше в документации по стилизации элементов в [состояниях наведения, фокуса и других состояниях](/docs/hover-focus-and-other-states).

### Медиа-запросы и точки останова

Так же, как состояния наведения и фокуса, вы можете стилизовать элементы на разных точках останова, добавив префикс к любой утилите с точкой останова, где вы хотите, чтобы этот стиль применялся:

<Figure hint="Измените размер этого примера, чтобы увидеть изменение макета">

<Example className="@container" resizable>
  {
    <div className="grid grid-cols-2 gap-4 text-center font-mono font-medium text-white @sm:grid-cols-3">
      <div className="rounded-lg bg-sky-500 p-4">01</div>
      <div className="rounded-lg bg-sky-500 p-4">02</div>
      <div className="rounded-lg bg-sky-500 p-4">03</div>
      <div className="rounded-lg bg-sky-500 p-4">04</div>
      <div className="rounded-lg bg-sky-500 p-4">05</div>
      <div className="rounded-lg bg-sky-500 p-4">06</div>
    </div>
  }
</Example>

```html
<!-- [!code classes:sm:grid-cols-3] -->
<div class="grid grid-cols-2 sm:grid-cols-3">
  <!-- ... -->
</div>
```

</Figure>

В приведенном выше примере префикс `sm:` гарантирует, что `grid-cols-3` сработает только на точке останова `sm` и выше, что составляет 40rem по умолчанию:

```css
/* [!code filename: Generated CSS] */
.sm\:grid-cols-3 {
  @media (width >= 40rem) {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}
```

Узнайте больше в документации по [адаптивному дизайну](/docs/responsive-design).

### Нацеливание на темный режим

Стилизация элемента в темном режиме — это просто добавление префикса `dark:` к любой утилите, которую вы хотите применить, когда активен темный режим:

<Figure>

<Example padding={false}>
  {
    <div className="grid grid-cols-1 sm:grid-cols-2">
      <div className="p-8 pt-7">
        <p className="mb-2 text-sm font-medium text-gray-500">Светлый режим</p>
        <div className="rounded-lg bg-white px-6 py-8 shadow-xl ring ring-gray-900/5">
          <div>
            <span className="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
              <svg
                className="h-6 w-6 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                aria-hidden="true"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                />
              </svg>
            </span>
          </div>
          <p className="mt-5 text-base font-medium tracking-tight text-gray-900">Пишет вверх ногами</p>
          <p
            className="mt-2 text-sm text-gray-500"
            children={`Ручка Zero Gravity может использоваться для письма в любом положении,
          включая вверх ногами. Она даже работает в космосе.`}
          />
        </div>
      </div>
      <div className="bg-gray-900 p-8 pt-7">
        <p className="mb-2 text-sm font-medium text-gray-400">Темный режим</p>
        <div className="rounded-lg bg-gray-800 px-6 py-8 shadow-xl ring ring-gray-900/5">
          <div>
            <span className="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
              <svg
                className="h-6 w-6 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                aria-hidden="true"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                />
              </svg>
            </span>
          </div>
          <p className="mt-5 text-base font-medium tracking-tight text-white">Пишет вверх ногами</p>
          <p
            className="mt-2 text-sm text-gray-400"
            children={`Ручка Zero Gravity может использоваться для письма в любом положении,
          включая вверх ногами. Она даже работает в космосе.`}
          />
        </div>
      </div>
    </div>
  }
</Example>

```html
<!-- [!code word:dark\:bg-gray-800] -->
<!-- prettier-ignore -->
<div class="bg-white dark:bg-gray-800 rounded-lg px-6 py-8 ring shadow-xl ring-gray-900/5">
  <div>
    <span class="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
      <svg
        class="h-6 w-6 text-white"

        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
      >
        <!-- ... -->
      </svg>
    </span>
  </div>
  <!-- prettier-ignore -->
  <!-- [!code word:dark\:text-white] -->
  <h3 class="text-gray-900 dark:text-white mt-5 text-base font-medium tracking-tight ">Пишет вверх ногами</h3>
  <!-- prettier-ignore -->
  <!-- [!code word:dark\:text-gray-400] -->
  <p class="text-gray-500 dark:text-gray-400 mt-2 text-sm ">
    Ручка Zero Gravity может использоваться для письма в любом положении, включая вверх ногами. Она даже работает в космосе.
  </p>
</div>
```

</Figure>

Так же, как с состояниями наведения или медиа-запросами, важно понимать, что один утилитарный класс никогда не будет включать _оба_ стиля — и для светлого, и для темного режимов. Вы стилизуете элементы в темном режиме, используя несколько классов: один для стилей светлого режима и другой для стилей темного режима.

```css
/* [!code filename: Generated CSS] */
.dark\:bg-gray-800 {
  @media (prefers-color-scheme: dark) {
    background-color: var(--color-gray-800);
  }
}
```

Узнайте больше в документации по [темному режиму](/docs/dark-mode).

### Использование композиции классов

Часто с Tailwind вы будете использовать несколько классов для создания значения для одного свойства CSS, например, добавляя несколько фильтров к элементу:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:blur-sm,grayscale] -->
<div class="blur-sm grayscale">
  <!-- ... -->
</div>
```

Оба этих эффекта зависят от свойства `filter` в CSS, поэтому Tailwind использует переменные CSS, чтобы сделать возможным комбинирование этих эффектов:

```css
/* [!code filename:Generated CSS] */
.blur-sm {
  --tw-blur: blur(var(--blur-sm));
  filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-grayscale,);
}
.grayscale {
  --tw-grayscale: grayscale(100%);
  filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-grayscale,);
}
```

The generated CSS above is slightly simplified, but the trick here is that each utility sets a CSS variable just for the effect it's meant to apply. Then the `filter` property looks at all of these variables, falling back to nothing if the variable hasn't been set.

Tailwind использует этот же подход для [градиентов](/docs/background-image#adding-a-linear-gradient), [цветов теней](/docs/box-shadow#setting-the-shadow-color), [трансформаций](/docs/translate) и многого другого.

### Использование произвольных значений

Многие утилиты в Tailwind управляются [переменными темы](/docs/theme), такими как `bg-blue-500`, `text-xl` и `shadow-md`, которые соответствуют вашей основной цветовой палитре, шкале типов и теням.

Когда вам нужно использовать одноразовое значение вне вашей темы, используйте специальный синтаксис квадратных скобок для указания произвольных значений:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-[#316ff6]] -->
<!-- prettier-ignore -->
<button class="bg-[#316ff6] ...">
  Войти с Facebook
</button>
```

Это может быть полезно для одноразовых цветов вне вашей цветовой палитры _(например, синий Facebook выше)_, но также когда вам нужно сложное пользовательское значение, такое как очень специфическая сетка:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:grid-cols-[24rem_2.5rem_minmax(0,1fr)]] -->
<div class="grid grid-cols-[24rem_2.5rem_minmax(0,1fr)]">
  <!-- ... -->
</div>
```

Это также полезно, когда вам нужно использовать функции CSS, такие как `calc()`, даже если вы используете значения вашей темы:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:max-h-[calc(100dvh-(--spacing(6)))]] -->
<div class="max-h-[calc(100dvh-(--spacing(6)))]">
  <!-- ... -->
</div>
```

Есть даже синтаксис для генерации полностью произвольного CSS, включая произвольное имя свойства, что может быть полезно для установки переменных CSS:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[--gutter-width:1rem],lg:[--gutter-width:2rem]] -->
<div class="[--gutter-width:1rem] lg:[--gutter-width:2rem]">
  <!-- ... -->
</div>
```

Узнайте больше в документации по [использованию произвольных значений](/docs/adding-custom-styles#using-arbitrary-values).

#### Как это вообще работает?

Tailwind CSS — это не один большой статический файл стилей, как вы могли бы привыкнуть с другими CSS-фреймворками — он генерирует необходимый CSS на основе классов, которые вы действительно используете при компиляции вашего CSS.

Он делает это, сканируя все файлы в вашем проекте в поисках любого символа, который выглядит как имя класса:

```jsx
// [!code filename:Button.jsx]
// [!code word:px-4]
// [!code word:py-2]
// [!code word:rounded-md]
// [!code word:text-base]
// [!code word:px-5]
// [!code word:py-3]
// [!code word:rounded-lg]
// [!code word:text-lg]
// [!code word:font-bold]
export default function Button({ size, children }) {
  let sizeClasses = {
    md: "px-4 py-2 rounded-md text-base",
    lg: "px-5 py-3 rounded-lg text-lg",
  }[size];

  return (
    <button type="button" className={`font-bold ${sizeClasses}`}>
      {children}
    </button>
  );
}
```

После того, как он нашел все потенциальные классы, Tailwind генерирует CSS для каждого из них и компилирует все это в один файл стилей, содержащий только те стили, которые вам действительно нужны.

Поскольку CSS генерируется на основе имени класса, Tailwind может распознавать классы с произвольными значениями, такими как `bg-[#316ff6]`, и генерировать необходимый CSS, даже если значение не является частью вашей темы.

Узнайте больше о том, как это работает, в разделе [обнаружение классов в исходных файлах](/docs/detecting-classes-in-source-files).

### Сложные селекторы

Иногда вам нужно стилизовать элемент при сочетании условий, например, в темном режиме, на определенной точке останова, при наведении и когда элемент имеет определенный атрибут данных.

Вот пример того, как это выглядит с Tailwind:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:dark:lg:data-current:hover:bg-indigo-600] -->
<button class="dark:lg:data-current:hover:bg-indigo-600 ...">
  <!-- ... -->
</button>
```

```css
/* [!code filename:Simplified CSS] */
@media (prefers-color-scheme: dark) and (width >= 64rem) {
  button[data-current]:hover {
    background-color: var(--color-indigo-600);
  }
}
```

</CodeExampleStack>

Tailwind также поддерживает такие вещи, как `group-hover`, которые позволяют стилизовать элемент, когда определенный родитель наведен:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:group,group-hover:underline] -->
<a href="#" class="group rounded-lg p-8">
  <!-- ... -->
  <span class="group-hover:underline">Читать далее…</span>
</a>
```

```css
/* [!code filename:Simplified CSS] */
@media (hover: hover) {
  a:hover span {
    text-decoration-line: underline;
  }
}
```

</CodeExampleStack>

Этот синтаксис `group-*` работает и с другими вариантами, такими как `group-focus`, `group-active` и [многими другими](/docs/hover-focus-and-other-states#styling-based-on-parent-state).

Для действительно сложных сценариев _(особенно при стилизации HTML, который вы не контролируете)_, Tailwind поддерживает [произвольные варианты](/docs/adding-custom-styles#arbitrary-variants), которые позволяют вам писать любой селектор, который вы хотите, прямо в имени класса:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[&>[data-active]+span]:text-blue-600] -->
<div class="[&>[data-active]+span]:text-blue-600 ...">
  <span data-active><!-- ... --></span>
  <!-- [!code highlight:2] -->
  <span>Этот текст будет синим</span>
</div>
```

```css
/* [!code filename:Simplified CSS] */
div > [data-active] + span {
  color: var(--color-blue-600);
}
```

</CodeExampleStack>

### Когда использовать встроенные стили

Встроенные стили все еще очень полезны в проектах Tailwind CSS, особенно когда значение поступает из динамического источника, такого как база данных или API:

```jsx
// [!code filename:branded-button.jsx]
export function BrandedButton({ buttonColor, textColor, children }) {
  return (
    <button
      style={{
        // [!code highlight:3]
        backgroundColor: buttonColor,
        color: textColor,
      }}
      className="rounded-md px-3 py-1.5 font-medium"
    >
      {children}
    </button>
  );
}
```

Вы также можете использовать встроенный стиль для очень сложных произвольных значений, которые трудно читать, когда они оформлены как имя класса:

```html
<!-- [!code filename:HTML] -->
<!-- prettier-ignore -->
<div class="grid-[2fr_max(0,var(--gutter-width))_calc(var(--gutter-width)+10px)]"> <!-- [!code --] -->
<!-- prettier-ignore -->
<div style="grid-template-columns: 2fr max(0, var(--gutter-width)) calc(var(--gutter-width) + 10px)"> <!-- [!code ++] -->
  <!-- ... -->
</div>
```

Еще один полезный шаблон — установка переменных CSS на основе динамических источников с использованием встроенных стилей, а затем ссылка на эти переменные с помощью утилитарных классов:

```jsx
// [!code filename:branded-button.jsx]
export function BrandedButton({ buttonColor, buttonColorHover, textColor, children }) {
  return (
    <button
      style={{
        // [!code highlight:4]
        "--bg-color": buttonColor,
        "--bg-color-hover": buttonColorHover,
        "--text-color": textColor,
      }}
      // [!code classes:bg-(--bg-color),text-(--text-color),hover:bg-(--bg-color-hover)]
      className="bg-(--bg-color) text-(--text-color) hover:bg-(--bg-color-hover) ..."
    >
      {children}
    </button>
  );
}
```

## Управление дублированием

Когда вы создаете целые проекты, используя только утилитарные классы, вы неизбежно обнаружите, что повторяете определенные шаблоны для воссоздания одного и того же дизайна в разных местах.

Например, здесь утилитарные классы для каждого аватара повторяются пять раз:

<Figure>

<Example padding={false}>
  <div className="bg-white">
    <div className="mx-auto w-72 px-8 py-6 sm:w-96 sm:px-12 sm:py-8">
      <div className="flex items-center space-x-2 text-base">
        <h4 className="text-base font-semibold text-slate-900">Участники</h4>
        <span className="rounded-full bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700">204</span>
      </div>
      <div className="mt-3 flex -space-x-2 overflow-hidden">
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
      </div>
      <div className="mt-3 text-sm font-medium">
        <a href="#" className="text-blue-500">
          + 198 других
        </a>
      </div>
    </div>
  </div>
</Example>

```html
<!-- [!code classes:inline-block,h-12,w-12,rounded-full,ring-2,ring-white] -->
<div>
  <div class="flex items-center space-x-2 text-base">
    <h4 class="font-semibold text-slate-900">Участники</h4>
    <span class="bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700 ...">204</span>
  </div>
  <div class="mt-3 flex -space-x-2 overflow-hidden">
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
  </div>
  <div class="mt-3 text-sm font-medium">
    <a href="#" class="text-blue-500">+ 198 других</a>
  </div>
</div>
```

</Figure>

Не паникуйте! На практике это не проблема, о которой вы могли бы беспокоиться, и стратегии для ее решения — это то, что вы уже делаете каждый день.

### Использование циклов

Часто элемент дизайна, который появляется более одного раза на отображаемой странице, фактически создается только один раз, потому что фактическая разметка создается в цикле.

Например, дублирующиеся аватары в начале этого руководства почти наверняка будут создаваться в цикле в реальном проекте:

<Figure>

<Example padding={false}>
  <div className="bg-white">
    <div className="mx-auto w-72 px-8 py-6 sm:w-96 sm:px-12 sm:py-8">
      <div className="flex items-center space-x-2 text-base">
        <h4 className="text-base font-semibold text-slate-900">Участники</h4>
        <span className="rounded-full bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700">204</span>
      </div>
      <div className="mt-3 flex -space-x-2 overflow-hidden">
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
      </div>
      <div className="mt-3 text-sm font-medium">
        <a href="#" className="text-blue-500">
          + 198 других
        </a>
      </div>
    </div>
  </div>
</Example>

```svelte
<div>
  <div class="flex items-center space-x-2 text-base">
    <h4 class="font-semibold text-slate-900">Участники</h4>
    <span class="bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700 ...">204</span>
  </div>
  <div class="mt-3 flex -space-x-2 overflow-hidden">
    <!-- prettier-ignore -->
    <!-- [!code highlight:4] -->
    {#each contributors as user}
      <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src={user.avatarUrl} alt={user.handle} />
    {/each}
  </div>
  <div class="mt-3 text-sm font-medium">
    <a href="#" class="text-blue-500">+ 198 других</a>
  </div>
</div>
```

</Figure>

Когда элементы создаются в цикле таким образом, фактический список классов записывается только один раз, поэтому нет реальной проблемы дублирования, которую нужно решать.

### Использование многокурсорного редактирования

Когда дублирование локализовано в группе элементов в одном файле, самый простой способ справиться с этим — использовать [многокурсорное редактирование](https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor), чтобы быстро выбрать и отредактировать список классов для каждого элемента одновременно:

<MultiCursorAnimation>
  <Figure>
    <Example>
      <MultiCursorPreview />
    </Example>
    <CodeExampleWrapper>
      <MultiCursorCode />
    </CodeExampleWrapper>
  </Figure>
</MultiCursorAnimation>

Вы удивитесь, как часто это оказывается лучшим решением. Если вы можете быстро редактировать все дублированные списки классов одновременно, нет смысла вводить дополнительную абстракцию.

### Использование компонентов

Если вам нужно повторно использовать некоторые стили в нескольких файлах, лучшая стратегия — создать _компонент_, если вы используете фронтенд-фреймворк, такой как React, Svelte или Vue, или _частичный шаблон_, если вы используете шаблонизатор, такой как Blade, ERB, Twig или Nunjucks.

<Figure>

<Example padding={false}>
<div className="bg-white">
  <div className="mx-auto w-72 bg-white px-8 py-6  sm:w-96 sm:px-12 sm:py-8">
    <div>
      <img
        className="rounded-lg"
        src="https://images.unsplash.com/photo-1452784444945-3f422708fe5e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=512&q=80"
        width="512"
        height="341"
        alt="Пляж"
      />
      <div className="mt-4">
          <div className="text-xs font-bold text-sky-500">Частная вилла</div>
          <div className="mt-1 font-bold text-gray-700">
            <a href="#" className="hover:underline">Расслабляющий все включено курорт в Канкуне</a>
          </div>
          <div className="mt-2 text-sm text-gray-600">$299 USD за ночь</div>
      </div>
    </div>
  </div>
</div>

</Example>

```jsx {{ filename: 'VacationCard.jsx' }}
export function VacationCard({ img, imgAlt, eyebrow, title, pricing, url }) {
  return (
    <div>
      <img className="rounded-lg" src={img} alt={imgAlt} />
      <div className="mt-4">
        <div className="text-xs font-bold text-sky-500">{eyebrow}</div>
        <div className="mt-1 font-bold text-gray-700">
          <a href={url} className="hover:underline">
            {title}
          </a>
        </div>
        <div className="mt-2 text-sm text-gray-600">{pricing}</div>
      </div>
    </div>
  );
}
```

</Figure>

Теперь вы можете использовать этот компонент в любом количестве мест, сохраняя при этом единый источник правды для стилей, чтобы их можно было легко обновить вместе в одном месте.

### Использование пользовательского CSS

Если вы используете шаблонизатор, такой как ERB или Twig, вместо чего-то вроде React или Vue, создание частичного шаблона для чего-то столь малого, как кнопка, может показаться излишним по сравнению с простым CSS-классом, таким как `btn`.

Хотя настоятельно рекомендуется создавать правильные частичные шаблоны для более сложных компонентов, написание некоторого пользовательского CSS вполне допустимо, когда частичный шаблон кажется чрезмерным.

Вот как может выглядеть класс `btn-primary`, используя [переменные темы](/docs/theme#with-custom-css) для поддержания согласованности дизайна:

<Figure>

<Example>

<div className="text-center">
  <button
    type="button"
    className="rounded-full bg-violet-500 px-5 py-2 font-semibold text-white shadow-md hover:bg-violet-700"
  >
    Сохранить изменения
  </button>
</div>

</Example>

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<button class="btn-primary">Сохранить изменения</button>
```

```css
/* [!code filename:CSS] */
@import "tailwindcss";

@layer components {
  .btn-primary {
    border-radius: calc(infinity * 1px);
    background-color: var(--color-violet-500);
    padding-inline: --spacing(5);
    padding-block: --spacing(2);
    font-weight: var(--font-weight-semibold);
    color: var(--color-white);
    box-shadow: var(--shadow-md);
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-violet-700);
      }
    }
  }
}
```

</CodeExampleStack>

</Figure>

Однако, для всего, что сложнее одного HTML-элемента, мы настоятельно рекомендуем использовать частичные шаблоны, чтобы стили и структура могли быть инкапсулированы в одном месте.

## Управление конфликтами стилей

### Конфликтующие утилитарные классы

Когда вы добавляете два класса, которые нацелены на одно и то же свойство CSS, класс, который появляется позже в таблице стилей, побеждает. Таким образом, в этом примере элемент получит `display: grid`, даже если `flex` идет последним в атрибуте `class`:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- prettier-ignore -->
<div class="grid flex">
  <!-- ... -->
</div>
```

```css
/* [!code filename: CSS] */
.flex {
  display: flex;
}
.grid {
  display: grid;
}
```

</CodeExampleStack>

В общем, вы никогда не должны добавлять два конфликтующих класса к одному элементу — добавляйте только тот, который вы действительно хотите, чтобы он применился:

```jsx
// [!code filename:example.jsx]
// [!code word:gridLayout\ \?\ \"grid\"\ \:\ \"flex\"]
export function Example({ gridLayout }) {
  return <div className={gridLayout ? "grid" : "flex"}>{/* ... */}</div>;
}
```

Используя библиотеки на основе компонентов, такие как React или Vue, это часто означает предоставление конкретных свойств для настройки стилей вместо того, чтобы позволять пользователям добавлять дополнительные классы извне компонента, так как эти стили часто будут конфликтовать.

### Использование модификатора important

Когда вам действительно нужно заставить конкретный утилитарный класс примениться и нет других средств управления специфичностью, вы можете добавить `!` в конец имени класса, чтобы сделать все объявления `!important`:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-red-500!] -->
<!-- prettier-ignore -->
<div class="bg-teal-500 bg-red-500!">
  <!-- ... -->
</div>
```

```css
/* [!code filename: Generated CSS] */
/* [!code word:!important] */
.bg-red-500\! {
  background-color: var(--color-red-500) !important;
}
.bg-teal-500 {
  background-color: var(--color-teal-500);
}
```

</CodeExampleStack>

### Использование флага important

Если вы добавляете Tailwind в проект, который уже имеет сложный CSS с высокой специфичностью правил, вы можете использовать флаг `important` при импорте Tailwind, чтобы пометить _все_ утилиты как `!important`:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
/* [!code word:important] */
@import "tailwindcss" important;
```

```css
/* [!code filename:Compiled CSS] */
/* [!code word:!important] */
@layer utilities {
  .flex {
    display: flex !important;
  }
  .gap-4 {
    gap: 1rem !important;
  }
  .underline {
    text-decoration-line: underline !important;
  }
}
```

</CodeExampleStack>

### Использование опции prefix

Если в вашем проекте есть имена классов, которые конфликтуют с утилитами Tailwind CSS, вы можете добавить префикс ко всем классам и переменным CSS, сгенерированным Tailwind, используя опцию `prefix`:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
/* [!code word:important] */
@import "tailwindcss" prefix(tw);
```

```css
/* [!code filename:Compiled CSS] */
/* [!code word:tw\:] */
@layer theme {
  :root {
    --tw-color-red-500: oklch(0.637 0.237 25.331);
  }
}

@layer utilities {
  .tw\:text-red-500 {
    color: var(--tw-color-red-500);
  }
}
```

</CodeExampleStack>
