import { Example } from "@/components/example";
import { CodeExampleWrapper, CodeExampleStack } from "@/components/code-example";
import { Iframe } from "@/components/iframe.tsx";
import { Figure } from "@/components/figure";
import { TipGood, TipBad, TipCompat, TipInfo } from "@/components/tips";
import { MultiCursorAnimation, MultiCursorPreview } from "@/components/multi-cursor/animation.tsx";
import { MultiCursorCode } from "@/components/multi-cursor/example.tsx";
import erinLindford from "./img/erin-lindford.jpg";

export const title = "Styling with utility classes";
export const description = "Построение сложных компонентов из ограниченного набора примитивных утилит.";

## Обзор

Вы стилизуете элементы в Tailwind, комбинируя множество однозадачных презентационных классов _(утилитарных классов)_ прямо в вашей разметке:

<Figure>

<Example>
  {
    <div className="mx-auto flex max-w-sm items-center gap-x-4 rounded-xl bg-white p-6 shadow-lg outline outline-black/5 dark:bg-slate-800 dark:shadow-none dark:-outline-offset-1 dark:outline-white/10">
      <svg className="size-12 shrink-0" viewBox="0 0 40 40">
        <defs>
          <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
            <stop stopColor="#2397B3" offset="0%"></stop>
            <stop stopColor="#13577E" offset="100%"></stop>
          </linearGradient>
          <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
            <stop stopColor="#73DFF2" offset="0%"></stop>
            <stop stopColor="#47B1EB" offset="100%"></stop>
          </linearGradient>
        </defs>
        <g fill="none" fillRule="evenodd">
          <path
            d="M28.872 22.096c.084.622.128 1.258.128 1.904 0 7.732-6.268 14-14 14-2.176 0-4.236-.496-6.073-1.382l-6.022 2.007c-1.564.521-3.051-.966-2.53-2.53l2.007-6.022A13.944 13.944 0 0 1 1 24c0-7.331 5.635-13.346 12.81-13.95A9.967 9.967 0 0 0 13 14c0 5.523 4.477 10 10 10a9.955 9.955 0 0 0 5.872-1.904z"
            fill="url(#a)"
            transform="translate(1 1)"
          ></path>
          <path
            d="M35.618 20.073l2.007 6.022c.521 1.564-.966 3.051-2.53 2.53l-6.022-2.007A13.944 13.944 0 0 1 23 28c-7.732 0-14-6.268-14-14S15.268 0 23 0s14 6.268 14 14c0 2.176-.496 4.236-1.382 6.073z"
            fill="url(#b)"
            transform="translate(1 1)"
          ></path>
          <path
            d="M18 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4zM24 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4zM30 17a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"
            fill="#FFF"
          ></path>
        </g>
      </svg>
      <div>
        <div className="text-xl font-medium text-black dark:text-white">ChitChat</div>
        <p className="text-gray-500 dark:text-gray-400">У вас новое сообщение!</p>
      </div>
    </div>
  }
</Example>

```html
<!-- prettier-ignore -->
<div class="mx-auto flex max-w-sm items-center gap-x-4 rounded-xl bg-white p-6 shadow-lg outline outline-black/5 dark:bg-slate-800 dark:shadow-none dark:-outline-offset-1 dark:outline-white/10">
  <img class="size-12 shrink-0" src="/img/logo.svg" alt="ChitChat Logo" />
  <div>
    <div class="text-xl font-medium text-black dark:text-white">ChitChat</div>
    <p class="text-gray-500 dark:text-gray-400">У вас новое сообщение!</p>
  </div>
</div>
```

</Figure>

Например, в приведённом выше UI мы использовали:

- Утилиты [display](/docs/display#flex) и [padding](/docs/padding) (`flex`, `shrink-0`, и `p-6`) для управления общим расположением
- Утилиты [max-width](/docs/max-width) и [margin](/docs/margin) (`max-w-sm` и `mx-auto`) для ограничения ширины карточки и центрирования по горизонтали
- Утилиты [background-color](/docs/background-color), [border-radius](/docs/border-radius) и [box-shadow](/docs/box-shadow) (`bg-white`, `rounded-xl` и `shadow-lg`) для стилизации внешнего вида карточки
- Утилиты [width](/docs/width) и [height](/docs/height) (`size-12`) для задания ширины и высоты логотипа
- Утилиты [gap](/docs/gap) (`gap-x-4`) для управления расстоянием между логотипом и текстом
- Утилиты [font-size](/docs/font-size), [color](/docs/text-color) и [font-weight](/docs/font-weight) (`text-xl`, `text-black`, `font-medium` и др.) для стилизации текста карточки

Стилизовать элементы таким образом противоречит многим традиционным best practices, но как только вы попробуете — быстро заметите важные преимущества:

- **Вы делаете всё быстрее** — не тратите время на придумывание имён классов, выбор селекторов или переключение между HTML и CSS, поэтому дизайн собирается очень быстро.
- **Вносить изменения безопаснее** — добавление или удаление утилитарного класса влияет только на этот элемент, поэтому не нужно бояться случайно сломать что-то на другой странице, использующей тот же CSS.
- **Сопровождать старые проекты проще** — чтобы что-то изменить, достаточно найти нужный элемент и поменять классы, а не вспоминать, как работает весь кастомный CSS, который вы не трогали полгода.
- **Ваш код становится более переносимым** — так как структура и стили находятся в одном месте, вы легко можете копировать и вставлять целые куски UI, даже между разными проектами.
- **CSS перестаёт разрастаться** — так как утилитарные классы очень переиспользуемы, ваш CSS не растёт линейно с каждым новым фичером.

Эти преимущества заметны даже на маленьких проектах, но особенно ценны для команд, работающих над большими долгоживущими продуктами.

### Почему бы просто не использовать инлайн-стили?

Частая реакция на такой подход — удивление: "разве это не просто инлайн-стили?" И в каком-то смысле так и есть — вы применяете стили напрямую к элементам вместо того, чтобы присвоить им имя класса и затем стилизовать этот класс.

Но использование утилитарных классов имеет много важных преимуществ перед инлайн-стилями, например:

- **Дизайн с ограничениями** — используя инлайн-стили, каждое значение становится магическим числом. С утилитами вы выбираете стили из [предопределённой системы дизайна](/docs/theme), что значительно упрощает создание визуально согласованных интерфейсов.
- **Наведение, фокус и другие состояния** — инлайн-стили не могут нацеливаться на состояния типа hover или focus, но [варианты состояний](/docs/hover-focus-and-other-states) Tailwind позволяют легко стилизовать эти состояния с помощью утилитарных классов.
- **Медиа-запросы** — вы не можете использовать медиа-запросы в инлайн-стилях, но можете использовать [адаптивные варианты](/docs/responsive-design) Tailwind для простого создания полностью адаптивных интерфейсов.

Этот компонент полностью адаптивен и включает кнопку с hover и active стилями, построенную полностью из утилитарных классов:

<Figure hint="Наведите на эту кнопку, чтобы увидеть изменение цвета фона">

<Example resizable>
  {
    <div className="mx-auto max-w-sm space-y-2 rounded-xl bg-white px-8 py-8 shadow-lg ring ring-black/5 @sm:flex @sm:items-center @sm:space-y-0 @sm:gap-x-6 @sm:py-4">
      <img
        className="mx-auto block h-24 rounded-full @sm:mx-0 @sm:shrink-0"
        src={erinLindford.src}
        alt="Woman's Face"
      />
      <div className="space-y-2 text-center @sm:text-left">
        <div className="space-y-0.5">
          <p className="text-lg font-semibold text-black">Erin Lindford</p>
          <p className="font-medium text-gray-500">Product Engineer</p>
        </div>
        <button className="rounded-full border border-purple-200 px-4 py-1 text-sm font-semibold text-purple-600 hover:border-transparent hover:bg-purple-600 hover:text-white active:bg-purple-700">
          Message
        </button>
      </div>
    </div>
  }
</Example>

```html
<!-- [!code classes:sm:flex-row,sm:py-4,sm:gap-6,sm:mx-0,sm:shrink-0,sm:text-left,sm:items-center] -->
<!-- [!code classes:hover:text-white,hover:bg-purple-600,hover:border-transparent,active:bg-purple-700] -->
<div class="flex flex-col gap-2 p-8 sm:flex-row sm:items-center sm:gap-6 sm:py-4 ...">
  <img class="mx-auto block h-24 rounded-full sm:mx-0 sm:shrink-0" src="/img/erin-lindford.jpg" alt="" />
  <div class="space-y-2 text-center sm:text-left">
    <div class="space-y-0.5">
      <p class="text-lg font-semibold text-black">Erin Lindford</p>
      <p class="font-medium text-gray-500">Product Engineer</p>
    </div>
    <!-- prettier-ignore -->
    <button class="border-purple-200 text-purple-600 hover:border-transparent hover:bg-purple-600 hover:text-white active:bg-purple-700 ...">
      Message
    </button>
  </div>
</div>
```

</Figure>

## Мышление в утилитарных классах

### Стилизация состояний hover и focus

Чтобы стилизовать элемент в состояниях типа hover или focus, добавьте к любой утилите префикс состояния, на которое хотите нацелиться, например `hover:bg-sky-700`:

<Figure hint="Наведите на эту кнопку, чтобы увидеть изменение цвета фона">

<Example>
  {
    <div className="grid place-items-center">
      <button className="rounded-full bg-sky-500 px-5 py-2 text-sm leading-5 font-semibold text-white hover:bg-sky-700">
        Сохранить изменения
      </button>
    </div>
  }
</Example>

```html
<!-- [!code word:hover\:bg-sky-700] -->
<button class="bg-sky-500 hover:bg-sky-700 ...">Сохранить изменения</button>
```

</Figure>

Эти префиксы называются [вариантами](/docs/hover-focus-and-other-states) в Tailwind, и они применяют стили из утилитарного класса только когда условие для этого варианта выполняется.

Вот как выглядит сгенерированный CSS для класса `hover:bg-sky-700`:

```css
/* [!code filename: Сгенерированный CSS] */
.hover\:bg-sky-700 {
  &:hover {
    background-color: var(--color-sky-700);
  }
}
```

Обратите внимание, что этот класс ничего не делает _если только_ элемент не находится в состоянии hover? Его _единственная_ задача — предоставить стили для hover — ничего больше.

Это отличается от того, как вы писали бы традиционный CSS, где один класс обычно предоставлял бы стили для многих состояний:

```html
/* [!code filename:HTML] */
<button class="btn">Сохранить изменения</button>

<style>
  .btn {
    background-color: var(--color-sky-500);
    &:hover {
      background-color: var(--color-sky-700);
    }
  }
</style>
```

Вы даже можете комбинировать варианты в Tailwind, чтобы применять утилиту, когда выполняются несколько условий, например, комбинируя `hover:` и `disabled:`:

```html
<!-- [!code classes:disabled:hover:bg-sky-500] -->
<button class="bg-sky-500 disabled:hover:bg-sky-500 ...">Сохранить изменения</button>
```

Узнайте больше в документации по стилизации элементов в [состояниях hover, focus и других](/docs/hover-focus-and-other-states).

### Медиа-запросы и контрольные точки

Так же, как состояния hover и focus, вы можете стилизовать элементы на разных контрольных точках, добавляя к любой утилите префикс контрольной точки(брейкпоинта), на котором хотите применить этот стиль:

<Figure hint="Измените размер этого примера, чтобы увидеть изменение макета">

<Example className="@container" resizable>
  {
    <div className="grid grid-cols-2 gap-4 text-center font-mono font-medium text-white @sm:grid-cols-3">
      <div className="rounded-lg bg-sky-500 p-4">01</div>
      <div className="rounded-lg bg-sky-500 p-4">02</div>
      <div className="rounded-lg bg-sky-500 p-4">03</div>
      <div className="rounded-lg bg-sky-500 p-4">04</div>
      <div className="rounded-lg bg-sky-500 p-4">05</div>
      <div className="rounded-lg bg-sky-500 p-4">06</div>
    </div>
  }
</Example>

```html
<!-- [!code classes:sm:grid-cols-3] -->
<div class="grid grid-cols-2 sm:grid-cols-3">
  <!-- ... -->
</div>
```

</Figure>

В примере выше префикс `sm:` гарантирует, что `grid-cols-3` срабатывает только на контрольной точке `sm` и выше, что составляет 40rem по умолчанию:

```css
/* [!code filename: Сгенерированный CSS] */
.sm\:grid-cols-3 {
  @media (width >= 40rem) {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}
```

Узнайте больше в документации по [адаптивному дизайну](/docs/responsive-design).

### Нацеливание на тёмный режим

Стилизовать элемент в тёмном режиме — это просто вопрос добавления префикса `dark:` к любой утилите, которую вы хотите применить, когда активен тёмный режим:

<Figure>

<Example padding={false}>
  {
    <div className="grid grid-cols-1 sm:grid-cols-2">
      <div className="p-8 pt-7">
        <p className="mb-2 text-sm font-medium text-gray-500">Светлый режим</p>
        <div className="rounded-lg bg-white px-6 py-8 shadow-xl ring ring-gray-900/5">
          <div>
            <span className="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
              <svg
                className="h-6 w-6 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                aria-hidden="true"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                />
              </svg>
            </span>
          </div>
          <p className="mt-5 text-base font-medium tracking-tight text-gray-900">Пишет вверх ногами</p>
          <p
            className="mt-2 text-sm text-gray-500"
            children={`Ручка Zero Gravity может использоваться для письма в любой ориентации,
          включая вверх ногами. Она даже работает в космосе.`}
          />
        </div>
      </div>
      <div className="bg-gray-900 p-8 pt-7">
        <p className="mb-2 text-sm font-medium text-gray-400">Тёмный режим</p>
        <div className="rounded-lg bg-gray-800 px-6 py-8 shadow-xl ring ring-gray-900/5">
          <div>
            <span className="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
              <svg
                className="h-6 w-6 text-white"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                aria-hidden="true"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"
                />
              </svg>
            </span>
          </div>
          <p className="mt-5 text-base font-medium tracking-tight text-white">Пишет вверх ногами</p>
          <p
            className="mt-2 text-sm text-gray-400"
            children={`Ручка Zero Gravity может использоваться для письма в любой ориентации,
          включая вверх ногами. Она даже работает в космосе.`}
          />
        </div>
      </div>
    </div>
  }
</Example>

```html
<!-- [!code word:dark\:bg-gray-800] -->
<!-- prettier-ignore -->
<div class="bg-white dark:bg-gray-800 rounded-lg px-6 py-8 ring shadow-xl ring-gray-900/5">
  <div>
    <span class="inline-flex items-center justify-center rounded-md bg-indigo-500 p-2 shadow-lg">
      <svg
        class="h-6 w-6 text-white"

        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
        aria-hidden="true"
      >
        <!-- ... -->
      </svg>
    </span>
  </div>
  <!-- prettier-ignore -->
  <!-- [!code word:dark\:text-white] -->
  <h3 class="text-gray-900 dark:text-white mt-5 text-base font-medium tracking-tight ">Пишет вверх ногами</h3>
  <!-- prettier-ignore -->
  <!-- [!code word:dark\:text-gray-400] -->
  <p class="text-gray-500 dark:text-gray-400 mt-2 text-sm ">
    Ручка Zero Gravity может использоваться для письма в любой ориентации, включая вверх ногами. Она даже работает в космосе.
  </p>
</div>
```

</Figure>

Так же, как с состояниями hover или медиа-запросами, важно понимать, что один утилитарный класс никогда не будет включать _оба_ светлых и тёмных стиля — вы стилизуете элементы в тёмном режиме, используя несколько классов, один для светлых стилей и другой для тёмных стилей.

```css
/* [!code filename: Сгенерированный CSS] */
.dark\:bg-gray-800 {
  @media (prefers-color-scheme: dark) {
    background-color: var(--color-gray-800);
  }
}
```

Узнайте больше в документации по [тёмному режиму](/docs/dark-mode).

### Использование композиции классов

Много раз с Tailwind вы будете даже использовать несколько классов для создания значения для одного CSS свойства, например добавляя несколько фильтров к элементу:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:blur-sm,grayscale] -->
<div class="blur-sm grayscale">
  <!-- ... -->
</div>
```

Оба этих эффекта основаны на свойстве `filter` в CSS, поэтому Tailwind использует CSS-переменные, чтобы сделать возможным композицию этих эффектов вместе:

```css
/* [!code filename:Generated CSS] */
.blur-sm {
  --tw-blur: blur(var(--blur-sm));
  filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-grayscale,);
}
.grayscale {
  --tw-grayscale: grayscale(100%);
  filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-grayscale,);
}
```

Сгенерированный CSS выше немного упрощён, но хитрость здесь в том, что каждая утилита устанавливает CSS-переменную только для того эффекта, который она должна применить. Затем свойство `filter` смотрит на все эти переменные, возвращаясь к пустому значению, если переменная не была установлена.

Tailwind использует этот же подход для [градиентов](/docs/background-image#adding-a-linear-gradient), [цветов теней](/docs/box-shadow#setting-the-shadow-color), [трансформаций](/docs/translate) и многого другого.

### Использование произвольных значений

Много утилит в Tailwind являются [темами переменных](/docs/theme), такими как `bg-blue-500`, `text-xl`, и `shadow-md`, которые сопоставляются с вашим базовым палитрой, шкалой типов, и тенями.

Когда вам нужно использовать одноразовое значение вне вашей темы, используйте специальную квадратную скобочную нотацию для указания произвольных значений:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-[#316ff6]] -->
<!-- prettier-ignore -->
<button class="bg-[#316ff6] ...">
  Sign in with Facebook
</button>
```

Это может быть полезно для одноразовых цветов вне вашей палитры _(как выше для Facebook blue)_, но также, когда вам нужно сложное значение, например сложный сетка:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:grid-cols-[24rem_2.5rem_minmax(0,1fr)]] -->
<div class="grid grid-cols-[24rem_2.5rem_minmax(0,1fr)]">
  <!-- ... -->
</div>
```

Это также полезно, когда вам нужно использовать CSS функции, даже если вы используете свои значения темы:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:max-h-[calc(100dvh-(--spacing(6)))]] -->
<div class="max-h-[calc(100dvh-(--spacing(6)))]">
  <!-- ... -->
</div>
```

Есть даже синтаксис для генерации полностью произвольного CSS, включая произвольное имя свойства, что может быть полезно для установки CSS переменных:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[--gutter-width:1rem],lg:[--gutter-width:2rem]] -->
<div class="[--gutter-width:1rem] lg:[--gutter-width:2rem]">
  <!-- ... -->
</div>
```

Узнайте больше в документации по [использованию произвольных значений](/docs/adding-custom-styles#using-arbitrary-values).

#### Как это вообще работает?

Tailwind CSS не один большой статический лист стилей, как вы могли бы привыкнуть с другими CSS фреймворками — он генерирует необходимый CSS на основе классов, которые вы фактически используете при компиляции CSS.

Это делается сканированием всех файлов в вашем проекте, чтобы найти любой символ, который может выглядеть как имя класса:

```jsx
// [!code filename:Button.jsx]
// [!code word:px-4]
// [!code word:py-2]
// [!code word:rounded-md]
// [!code word:text-base]
// [!code word:px-5]
// [!code word:py-3]
// [!code word:rounded-lg]
// [!code word:text-lg]
// [!code word:font-bold]
export default function Button({ size, children }) {
  let sizeClasses = {
    md: "px-4 py-2 rounded-md text-base",
    lg: "px-5 py-3 rounded-lg text-lg",
  }[size];

  return (
    <button type="button" className={`font-bold ${sizeClasses}`}>
      {children}
    </button>
  );
}
```

После того, как он найдет все потенциальные классы, Tailwind генерирует CSS для каждого и компилирует все в один лист стилей, содержащий только необходимые стили.

Так как CSS генерируется на основе имени класса, Tailwind может распознавать классы, используя произвольные значения, такие как `bg-[#316ff6]`, и генерировать необходимый CSS, даже если значение не является частью вашей темы.

Узнайте больше о том, как это работает в [обнаружении классов в исходных файлах](/docs/detecting-classes-in-source-files).

### Сложные селекторы

Иногда вам нужно стилизовать элемент под комбинацией условий, например в тёмном режиме, на конкретном брейкпоинте, когда элемент находится в состоянии hover, и когда элемент имеет конкретный атрибут данных.

Вот пример того, как это выглядит с Tailwind:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:dark:lg:data-current:hover:bg-indigo-600] -->
<button class="dark:lg:data-current:hover:bg-indigo-600 ...">
  <!-- ... -->
</button>
```

```css
/* [!code filename:Simplified CSS] */
@media (prefers-color-scheme: dark) and (width >= 64rem) {
  button[data-current]:hover {
    background-color: var(--color-indigo-600);
  }
}
```

</CodeExampleStack>

Tailwind также поддерживает вещи, такие как `group-hover`, которые позволяют вам стилизовать элемент, когда конкретный родитель находится в состоянии hover:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:group,group-hover:underline] -->
<a href="#" class="group rounded-lg p-8">
  <!-- ... -->
  <span class="group-hover:underline">Read more…</span>
</a>
```

```css
/* [!code filename:Simplified CSS] */
@media (hover: hover) {
  a:hover span {
    text-decoration-line: underline;
  }
}
```

</CodeExampleStack>

Этот `group-*` синтаксис работает с другими вариантами тоже, как `group-focus`, `group-active`, и [многими другими](/docs/hover-focus-and-other-states#styling-based-on-parent-state).

Для действительно сложных сценариев _(особенно при стилизации HTML, который вы не контролируете)_, Tailwind поддерживает [произвольные варианты](/docs/adding-custom-styles#arbitrary-variants), которые позволяют вам написать любой селектор, который вы хотите, прямо в имени класса:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[&>[data-active]+span]:text-blue-600] -->
<div class="[&>[data-active]+span]:text-blue-600 ...">
  <span data-active><!-- ... --></span>
  <!-- [!code highlight:2] -->
  <span>This text will be blue</span>
</div>
```

```css
/* [!code filename:Simplified CSS] */
div > [data-active] + span {
  color: var(--color-blue-600);
}
```

</CodeExampleStack>

### Когда использовать инлайн-стили

Инлайн-стили все еще очень полезны в Tailwind CSS проектах, особенно когда значение приходит из динамического источника, такого как база данных или API:

```jsx
// [!code filename:branded-button.jsx]
export function BrandedButton({ buttonColor, textColor, children }) {
  return (
    <button
      style={{
        // [!code highlight:3]
        backgroundColor: buttonColor,
        color: textColor,
      }}
      className="rounded-md px-3 py-1.5 font-medium"
    >
      {children}
    </button>
  );
}
```

Вы также можете использовать инлайн-стиль для очень сложных произвольных значений, которые трудно прочитать, когда они форматируются как имя класса:

```html
<!-- [!code filename:HTML] -->
<!-- prettier-ignore -->
<div class="grid-[2fr_max(0,var(--gutter-width))_calc(var(--gutter-width)+10px)]"> <!-- [!code --] -->
<!-- prettier-ignore -->
<div style="grid-template-columns: 2fr max(0, var(--gutter-width)) calc(var(--gutter-width) + 10px)"> <!-- [!code ++] -->
  <!-- ... -->
</div>
```

Другой полезный шаблон — установка CSS переменных на основе динамических источников с помощью инлайн-стилей, а затем ссылаться на эти переменные с помощью утилитарных классов:

```jsx
// [!code filename:branded-button.jsx]
export function BrandedButton({ buttonColor, buttonColorHover, textColor, children }) {
  return (
    <button
      style={{
        // [!code highlight:4]
        "--bg-color": buttonColor,
        "--bg-color-hover": buttonColorHover,
        "--text-color": textColor,
      }}
      // [!code classes:bg-(--bg-color),text-(--text-color),hover:bg-(--bg-color-hover)]
      className="bg-(--bg-color) text-(--text-color) hover:bg-(--bg-color-hover) ..."
    >
      {children}
    </button>
  );
}
```

## Управление дублированием

Когда вы создаете целые проекты только с утилитарными классами, вы, несомненно, столкнетесь с повторением определенных шаблонов, чтобы повторить один и тот же дизайн в разных местах.

Например, вот повторяющиеся классы для каждого изображения аватара:

<Figure>

<Example padding={false}>
  <div className="bg-white">
    <div className="mx-auto w-72 px-8 py-6 sm:w-96 sm:px-12 sm:py-8">
      <div className="flex items-center space-x-2 text-base">
        <h4 className="text-base font-semibold text-slate-900">Contributors</h4>
        <span className="rounded-full bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700">204</span>
      </div>
      <div className="mt-3 flex -space-x-2 overflow-hidden">
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
      </div>
      <div className="mt-3 text-sm font-medium">
        <a href="#" className="text-blue-500">
          + 198 others
        </a>
      </div>
    </div>
  </div>
</Example>

```html
<!-- [!code classes:inline-block,h-12,w-12,rounded-full,ring-2,ring-white] -->
<div>
  <div class="flex items-center space-x-2 text-base">
    <h4 class="font-semibold text-slate-900">Contributors</h4>
    <span class="bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700 ...">204</span>
  </div>
  <div class="mt-3 flex -space-x-2 overflow-hidden">
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
    <!-- prettier-ignore -->
    <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80" alt="" />
  </div>
  <div class="mt-3 text-sm font-medium">
    <a href="#" class="text-blue-500">+ 198 others</a>
  </div>
</div>
```

</Figure>

Не паникуйте! На практике это не та проблема, которой вы могли бы беспокоиться, и стратегии для её решения — это то, что вы уже делаете каждый день.

### Использование циклов

Часто дизайн-элемент, который появляется более одного раза на отрендеренной странице, на самом деле создаётся только один раз, потому что фактическая разметка рендерится в цикле.

Например, дублирующиеся аватары в начале этого руководства почти наверняка были бы отрендерены в цикле в реальном проекте:

<Figure>

<Example padding={false}>
  <div className="bg-white">
    <div className="mx-auto w-72 px-8 py-6 sm:w-96 sm:px-12 sm:py-8">
      <div className="flex items-center space-x-2 text-base">
        <h4 className="text-base font-semibold text-slate-900">Contributors</h4>
        <span className="rounded-full bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700">204</span>
      </div>
      <div className="mt-3 flex -space-x-2 overflow-hidden">
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2.25&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
        <img
          className="inline-block h-12 w-12 rounded-full ring-2 ring-white"
          src="https://images.unsplash.com/photo-1517365830460-955ce3ccd263?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"
          alt=""
        />
      </div>
      <div className="mt-3 text-sm font-medium">
        <a href="#" className="text-blue-500">
          + 198 others
        </a>
      </div>
    </div>
  </div>
</Example>

```svelte
<div>
  <div class="flex items-center space-x-2 text-base">
    <h4 class="font-semibold text-slate-900">Contributors</h4>
    <span class="bg-slate-100 px-2 py-1 text-xs font-semibold text-slate-700 ...">204</span>
  </div>
  <div class="mt-3 flex -space-x-2 overflow-hidden">
    <!-- prettier-ignore -->
    <!-- [!code highlight:4] -->
    {#each contributors as user}
      <img class="inline-block h-12 w-12 rounded-full ring-2 ring-white" src={user.avatarUrl} alt={user.handle} />
    {/each}
  </div>
  <div class="mt-3 text-sm font-medium">
    <a href="#" class="text-blue-500">+ 198 others</a>
  </div>
</div>
```

</Figure>

Когда элементы создаются в цикле, фактический список классов создается только один раз, поэтому нет реальной проблемы с дублированием.

### Использование мультикурсора редактирования

Когда дублирование локализовано в группе элементов в одном файле, самый простой способ справиться с этим — использовать [мультикурсор редактирования](https://code.visualstudio.com/docs/editor/codebasics#_multiple-selections-multicursor) для быстрого выбора и редактирования списка классов для каждого элемента одновременно:

<MultiCursorAnimation>
  <Figure>
    <Example>
      <MultiCursorPreview />
    </Example>
    <CodeExampleWrapper>
      <MultiCursorCode />
    </CodeExampleWrapper>
  </Figure>
</MultiCursorAnimation>

Вы удивитесь, как часто это оказывается лучшим решением. Если вы можете быстро редактировать все дублирующиеся списки классов одновременно, нет смысла вводить дополнительные абстракции.

### Использование компонентов

Если вам нужно повторно использовать некоторые стили в нескольких файлах, лучшая стратегия — создать _компонент_, если вы используете фронтенд-фреймворк, такой как React, Svelte или Vue, или _шаблонную часть_, если вы используете шаблонный язык, такой как Blade, ERB, Twig или Nunjucks.

<Figure>

<Example padding={false}>
<div className="bg-white">
  <div className="mx-auto w-72 bg-white px-8 py-6  sm:w-96 sm:px-12 sm:py-8">
    <div>
      <img
        className="rounded-lg"
        src="https://images.unsplash.com/photo-1452784444945-3f422708fe5e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=512&q=80"
        width="512"
        height="341"
        alt="Beach"
      />
      <div className="mt-4">
          <div className="text-xs font-bold text-sky-500">Private Villa</div>
          <div className="mt-1 font-bold text-gray-700">
            <a href="#" className="hover:underline">Relaxing All-Inclusive Resort in Cancun</a>
          </div>
          <div className="mt-2 text-sm text-gray-600">$299 USD per night</div>
      </div>
    </div>
  </div>
</div>

</Example>

```jsx {{ filename: 'VacationCard.jsx' }}
export function VacationCard({ img, imgAlt, eyebrow, title, pricing, url }) {
  return (
    <div>
      <img className="rounded-lg" src={img} alt={imgAlt} />
      <div className="mt-4">
        <div className="text-xs font-bold text-sky-500">{eyebrow}</div>
        <div className="mt-1 font-bold text-gray-700">
          <a href={url} className="hover:underline">
            {title}
          </a>
        </div>
        <div className="mt-2 text-sm text-gray-600">{pricing}</div>
      </div>
    </div>
  );
}
```

</Figure>

Теперь вы можете использовать этот компонент в стольких местах, сколько захотите, при этом сохраняя единый источник истины для стилей, чтобы их можно было легко обновлять вместе в одном месте.

### Использование пользовательского CSS

Если вы используете шаблонный язык, такой как ERB или Twig, вместо чего-то вроде React или Vue, создание шаблонной части для чего-то такого маленького, как кнопка, может показаться избыточным по сравнению с простым CSS классом, таким как `btn`.

Хотя настоятельно рекомендуется создавать правильные шаблонные части для более сложных компонентов, написание некоторого пользовательского CSS вполне допустимо, когда шаблонная часть кажется слишком громоздкой.

Вот как может выглядеть класс `btn-primary`, используя [переменные темы](/docs/theme#with-custom-css) для сохранения согласованности дизайна:

<Example>

<div className="text-center">
  <button
    type="button"
    className="rounded-full bg-violet-500 px-5 py-2 font-semibold text-white shadow-md hover:bg-violet-700"
  >
    Сохранить изменения
  </button>
</div>

</Example>

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<button class="btn-primary">Сохранить изменения</button>
```

```css
/* [!code filename:CSS] */
@import "tailwindcss";

@layer components {
  .btn-primary {
    border-radius: calc(infinity * 1px);
    background-color: var(--color-violet-500);
    padding-inline: --spacing(5);
    padding-block: --spacing(2);
    font-weight: var(--font-weight-semibold);
    color: var(--color-white);
    box-shadow: var(--shadow-md);
    &:hover {
      @media (hover: hover) {
        background-color: var(--color-violet-700);
      }
    }
  }
}
```

</CodeExampleStack>

Однако, для чего-то более сложного, чем просто HTML элемент, мы настоятельно рекомендуем использовать шаблонные части, чтобы стили и структура могли быть заключены в одном месте.

## Управление конфликтами стилей

### Конфликтные утилитарные классы

Когда вы добавляете два класса, которые нацелены на одно CSS свойство, класс, который появляется последним в стилях, выигрывает. Так в этом примере элемент получит `display: grid` даже если `flex` приходит последним в фактическом `class` атрибуте:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- prettier-ignore -->
<div class="grid flex">
  <!-- ... -->
</div>
```

```css
/* [!code filename: CSS] */
.flex {
  display: flex;
}
.grid {
  display: grid;
}
```

</CodeExampleStack>

В целом вы должны просто никогда не добавлять два конфликтующих класса к одному элементу — всегда добавляйте только один, который вы действительно хотите применить:

```jsx
// [!code filename:example.jsx]
// [!code word:gridLayout\ \?\ \"grid\"\ \:\ \"flex\"]
export function Example({ gridLayout }) {
  return <div className={gridLayout ? "grid" : "flex"}>{/* ... */}</div>;
}
```

Используя компонентно-ориентированные библиотеки, такие как React или Vue, это часто означает предоставление конкретных пропов для стилизации пользовательских настроек вместо того, чтобы позволять потребляющим добавлять дополнительные классы извне компонента, так как эти стили часто конфликтовать.

### Использование важного модификатора

Когда вам действительно нужно принудительно применить конкретный утилитарный класс и не иметь другого способа управления специфичностью, вы можете добавить `!` в конец имени класса, чтобы сделать все объявления `!important`:

<CodeExampleStack>

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-red-500!] -->
<!-- prettier-ignore -->
<div class="bg-teal-500 bg-red-500!">
  <!-- ... -->
</div>
```

```css
/* [!code filename: Generated CSS] */
/* [!code word:!important] */
.bg-red-500\! {
  background-color: var(--color-red-500) !important;
}
.bg-teal-500 {
  background-color: var(--color-teal-500);
}
```

</CodeExampleStack>

### Использование важного флага

Если вы добавляете Tailwind в проект, который имеет существующий сложный CSS с высокой специфичностью правилами, вы можете использовать `important` флаг при импорте Tailwind для отмечания _всех_ утилит как `!important`:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
/* [!code word:important] */
@import "tailwindcss" important;
```

```css
/* [!code filename:Compiled CSS] */
/* [!code word:!important] */
@layer utilities {
  .flex {
    display: flex !important;
  }
  .gap-4 {
    gap: 1rem !important;
  }
  .underline {
    text-decoration-line: underline !important;
  }
}
```

</CodeExampleStack>

### Использование префиксного параметра

Если у вашего проекта есть имена классов, которые конфликтуют с утилитами Tailwind CSS, вы можете префикс все утилитарные классы и CSS переменные, используя `prefix` параметр:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
/* [!code word:important] */
@import "tailwindcss" prefix(tw);
```

```css
/* [!code filename:Compiled CSS] */
/* [!code word:tw\:] */
@layer theme {
  :root {
    --tw-color-red-500: oklch(0.637 0.237 25.331);
  }
}

@layer utilities {
  .tw\:text-red-500 {
    color: var(--tw-color-red-500);
  }
}
```

</CodeExampleStack>
