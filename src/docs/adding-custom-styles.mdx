import { CodeExampleStack } from "@/components/code-example";

export const title = "Добавление пользовательских стилей";
export const description = "Лучшие практики добавления собственных стилей в проекты Tailwind.";

Часто самая большая проблема при работе с фреймворком заключается в том, чтобы понять, что делать, когда вам нужно что-то, чего фреймворк не обрабатывает для вас.

Tailwind был разработан с нуля для того, чтобы быть расширяемым и настраиваемым, чтобы вы никогда не чувствовали, что боретесь с фреймворком, независимо от того, что вы строите.

В этом руководстве рассматриваются такие темы, как настройка ваших токенов дизайна, как выходить за рамки этих ограничений при необходимости, добавление своего собственного пользовательского CSS и расширение фреймворка с помощью плагинов.

## Кастомизация вашей темы

Если вы хотите изменить такие вещи, как цветовая палитра, масштаб отступов, масштаб типографики или точки останова, добавьте свои настройки с помощью директивы `@theme` в вашем CSS:

```css
/* [!code filename:CSS] */
@theme {
  --font-display: "Satoshi", "sans-serif";

  --breakpoint-3xl: 120rem;

  --color-avocado-100: oklch(0.99 0 0);
  --color-avocado-200: oklch(0.98 0.04 113.22);
  --color-avocado-300: oklch(0.94 0.11 115.03);
  --color-avocado-400: oklch(0.92 0.19 114.08);
  --color-avocado-500: oklch(0.84 0.18 117.33);
  --color-avocado-600: oklch(0.53 0.12 118.34);

  --ease-fluid: cubic-bezier(0.3, 0, 0, 1);
  --ease-snappy: cubic-bezier(0.2, 0, 0, 1);

  /* ... */
}
```
Узнайте больше о настройке вашей темы в [документации по переменным темы](/docs/theme).

## Использование произвольных значений

Хотя обычно вы можете создать большую часть хорошо продуманного дизайна, используя ограниченный набор токенов дизайна, иногда вам нужно выйти за рамки этих ограничений, чтобы получить пиксель-идеальное расположение элементов.

Когда вы действительно нуждаетесь в чем-то вроде `top: 117px`, чтобы разместить фоновое изображение в нужном месте, используйте квадратные скобки Tailwind, чтобы сгенерировать класс на лету с любым произвольным значением:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:top-[117px]] -->
<div class="top-[117px]">
  <!-- ... -->
</div>
```

Это похоже на встроенные стили, с основным преимуществом, что вы можете комбинировать его с интерактивными модификаторами, такими как `hover`, и адаптивными модификаторами, такими как `lg`:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:top-[117px],lg:top-[344px]] -->
<div class="top-[117px] lg:top-[344px]">
  <!-- ... -->
</div>
```

Это работает для всего в фреймворке, включая такие вещи, как цвета фона, размеры шрифта, содержимое псевдоэлементов и многое другое:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-[#bada55],text-[22px],before:content-['Festivus']] -->
<div class="bg-[#bada55] text-[22px] before:content-['Festivus']">
  <!-- ... -->
</div>
```

Если вы ссылаетесь на переменную CSS в качестве произвольного значения, вы можете использовать синтаксис пользовательского свойства:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:fill-(--my-brand-color)] -->
<div class="fill-(--my-brand-color) ...">
  <!-- ... -->
</div>
```

Это просто сокращение для <code>fill-{'[var(--my-brand-color)]'}</code>, которое автоматически добавляет функцию `var()`.

### Произвольные свойства

Если вам когда-либо понадобится использовать свойство CSS, для которого Tailwind не включает утилиту, вы также можете использовать квадратные скобки, чтобы написать полностью произвольный CSS:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[mask-type:luminance]] -->
<div class="[mask-type:luminance]">
  <!-- ... -->
</div>
```

Это _на самом деле_ похоже на встроенные стили, но снова с преимуществом, что вы можете использовать модификаторы:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[mask-type:luminance],hover:[mask-type:alpha]] -->
<div class="[mask-type:luminance] hover:[mask-type:alpha]">
  <!-- ... -->
</div>
```

Это может быть полезно и для таких вещей, как переменные CSS, особенно когда они должны изменяться в зависимости от разных условий:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:[--scroll-offset:56px],lg:[--scroll-offset:44px]] -->
<div class="[--scroll-offset:56px] lg:[--scroll-offset:44px]">
  <!-- ... -->
</div>
```

### Произвольные варианты

Произвольные варианты похожи на произвольные значения, но для модификации селектора на лету, как вы можете это делать с встроенными псевдоклассовыми вариантами, такими как `hover:{utility}` или адаптивными вариантами, такими как `md:{utility}`, но с использованием квадратных скобок непосредственно в вашем HTML.

```html
<!-- [!code filename:HTML] -->
<!-- [!code word:\[&\:nth-child(-n+3)\]] -->
<ul role="list">
  {#each items as item}
  <li class="lg:[&:nth-child(-n+3)]:hover:underline">{item}</li>
  {/each}
</ul>
```

Узнайте больше в документации [по произвольным вариантам](/docs/hover-focus-and-other-states#using-arbitrary-variants).

### Обработка пробелов

Когда произвольное значение должно содержать пробел, используйте подчеркивание (`_`) вместо него, и Tailwind автоматически преобразует его в пробел во время сборки

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:grid-cols-[1fr_500px_2fr]] -->
<div class="grid grid-cols-[1fr_500px_2fr]">
  <!-- ... -->
</div>
```

В ситуациях, когда подчеркивания являются общими, но пробелы недопустимы, Tailwind сохранит подчеркивание вместо преобразования его в пробел, например, в URL-адресах:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-[url('/what_a_rush.png')]] -->
<div class="bg-[url('/what_a_rush.png')]">
  <!-- ... -->
</div>
```

В редких случаях, когда вам действительно нужно использовать подчеркивание, но это вызывает неоднозначность, потому что пробел также допустим, экранируйте подчеркивание обратной косой чертой, и Tailwind не преобразует его в пробел:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:before:content-['hello\_world']] -->
<div class="before:content-['hello\_world']">
  <!-- ... -->
</div>
```

Если вы используете что-то вроде JSX, где обратная косая черта удаляется из отображаемого HTML, используйте [String.raw()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw), чтобы обратная косая черта не рассматривалась как символ экранирования JavaScript:

```jsx
<div className={String.raw`before:content-['hello\_world']`}>
  <!-- ... -->
</div>
```

### Разрешение неоднозначности

Многие утилиты в Tailwind разделяют общее пространство имен, но отображаются на разные свойства CSS. Например, `text-lg` и `text-black` оба используют пространство имен `text-`, но один предназначен для `font-size`, а другой - для `color`.

При использовании произвольных значений Tailwind обычно может автоматически разрешить эту неоднозначность на основе переданного вами значения:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:text-[22px],text-[#bada55]] -->
<!-- Will generate a font-size utility -->
<div class="text-[22px]">...</div>

<!-- Will generate a color utility -->
<div class="text-[#bada55]">...</div>
```

Иногда это действительно вызывает неоднозначность, например, при использовании переменных CSS:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:text-(--my-var)] -->
<div class="text-(--my-var)">...</div>
```

В этих ситуациях вы можете "подсказать" базовый тип Tailwind, добавив [тип данных CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types) перед значением:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:text-(length:--my-var),text-(color:--my-var)] -->
<!-- Will generate a font-size utility -->
<div class="text-(length:--my-var)">...</div>

<!-- Will generate a color utility -->
<div class="text-(color:--my-var)">...</div>
```

## Использование пользовательского CSS

Хотя Tailwind предназначен для обработки большей части ваших потребностей в стилизации, ничто не мешает вам просто писать обычный CSS, когда это необходимо:

```css
/* [!code filename:CSS] */
@import "tailwindcss";

/* [!code highlight:4] */
.my-custom-style {
  /* ... */
}
```

### Добавление базовых стилей

Если вы просто хотите установить некоторые значения по умолчанию для страницы (например, цвет текста, цвет фона или семейство шрифтов), самым простым вариантом будет добавление некоторых классов к элементам `html` или `body`:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:bg-gray-100,font-serif,text-gray-900] -->
<!doctype html>
<html lang="en" class="bg-gray-100 font-serif text-gray-900">
  <!-- ... -->
</html>
```

Это позволяет сохранить ваши базовые стили в разметке вместе со всеми остальными стилями, вместо того чтобы скрывать их в отдельном файле.

Если вы хотите добавить свои собственные базовые стили по умолчанию для конкретных HTML-элементов, используйте директиву `@layer`, чтобы добавить эти стили в слой `base` Tailwind:

```css
/* [!code filename:CSS] */
/* [!code highlight:2] */
@layer base {
  h1 {
    font-size: var(--text-2xl);
  }

  h2 {
    font-size: var(--text-xl);
  }
  /* [!code highlight:2] */
}
```

### Добавление классов компонентов

Используйте слой `components` для любых более сложных классов, которые вы хотите добавить в свой проект и которые все еще можно переопределить с помощью утилитарных классов.

Традиционно это были классы, такие как `card`, `btn`, `badge` — такого рода вещи.

```css
/* [!code filename:CSS] */
/* [!code highlight:2] */
@layer components {
  .card {
    background-color: var(--color-white);
    border-radius: var(--rounded-lg);
    padding: var(--spacing-6);
    box-shadow: var(--shadow-xl);
  }
  /* [!code highlight:2] */
}
```

Определяя классы компонентов в слое `components`, вы все равно можете использовать утилитарные классы для их переопределения при необходимости:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:card,rounded-none] -->
<!-- Will look like a card, but with square corners -->
<div class="card rounded-none">
  <!-- ... -->
</div>
```

Используя Tailwind, вы, вероятно, не так часто используете эти типы классов, как вы думаете. Ознакомьтесь с нашим руководством по [управлению дублированием](/docs/styling-with-utility-classes#managing-duplication) для наших рекомендаций.

Слой `components` также является хорошим местом для размещения пользовательских стилей для любых сторонних компонентов, которые вы используете:

```css
/* [!code filename:CSS] */
@layer components {
  .select2-dropdown {
    /* ... */
  }
}
```

### Использование вариантов

Используйте директиву `@variant`, чтобы применить вариант Tailwind в пользовательском CSS:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
.my-element {
  background: white;

  /* [!code highlight:4] */
  @variant dark {
    background: black;
  }
}
```

```css
/* [!code filename:Compiled CSS] */
.my-element {
  background: white;

  /* [!code highlight:4] */
  @media (prefers-color-scheme: dark) {
    background: black;
  }
}
```

</CodeExampleStack>

Если вам необходимо применить несколько вариантов одновременно, используйте вложение:

<CodeExampleStack>

```css
/* [!code filename:app.css] */
.my-element {
  background: white;

  /* [!code highlight:6] */
  @variant dark {
    @variant hover {
      background: black;
    }
  }
}
```

```css
/* [!code filename:Compiled CSS] */
.my-element {
  background: white;

  /* [!code highlight:7] */
  @media (prefers-color-scheme: dark) {
    &:hover {
      @media (hover: hover) {
        background: black;
      }
    }
  }
}
```

</CodeExampleStack>

## Добавление пользовательских утилит

### Простые утилиты

Помимо использования утилит, которые поставляются с Tailwind, вы также можете добавить свои собственные пользовательские утилиты. Это может быть полезно, когда вы хотите использовать функцию CSS в своем проекте, для которой Tailwind не включает утилиты по умолчанию.

Используйте директиву `@utility`, чтобы добавить пользовательскую утилиту в ваш проект:

```css
/* [!code filename:CSS] */
@utility content-auto {
  content-visibility: auto;
}
```

Теперь вы можете использовать эту утилиту в вашем HTML:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:content-auto] -->
<div class="content-auto">
  <!-- ... -->
</div>
```

Она также будет работать с вариантами, такими как `hover`, `focus` и `lg`:

```html
<!-- [!code filename:HTML] -->
<!-- [!code classes:hover:content-auto] -->
<div class="hover:content-auto">
  <!-- ... -->
</div>
```

Пользовательские утилиты автоматически вставляются в слой `utilities` вместе со всеми встроенными утилитами в фреймворке.

### Сложные утилиты

Если ваша пользовательская утилита сложнее, чем одно имя класса, используйте вложенность для определения утилиты:

```css
/* [!code filename:CSS] */
@utility scrollbar-hidden {
  &::-webkit-scrollbar {
    display: none;
  }
}
```

### Функциональные утилиты

Помимо регистрации простых утилит с помощью директивы `@utility`, вы также можете регистрировать функциональные утилиты, которые принимают аргумент:

```css
/* [!code filename:CSS] */
@utility tab-* {
  /* prettier-ignore */
  tab-size: --value(--tab-size-*);
}
```

Специальная функция `--value()` используется для разрешения значения утилиты.

#### Соответствие значениям темы

Используйте синтаксис `--value(--theme-key-*)`, чтобы разрешить значение утилиты по набору ключей темы:

```css
/* [!code filename:CSS] */
@theme {
  --tab-size-2: 2;
  --tab-size-4: 4;
  --tab-size-github: 8;
}

@utility tab-* {
  /* [!code highlight:2] */
  /* prettier-ignore */
  tab-size: --value(--tab-size-*);
}
```

Это будет соответствовать утилитам, таким как `tab-2`, `tab-4` и `tab-github`.

#### Чистые значения

Чтобы разрешить значение как чистое значение, используйте синтаксис `--value({type})`, где `{type}` - это тип данных, который вы хотите проверить чистое значение на:

```css
/* [!code filename:CSS] */
@utility tab-* {
  tab-size: --value(integer);
}
```

Это будет соответствовать утилитам, таким как `tab-1` и `tab-76`.

#### Литеральные значения

Для поддержки литеральных значений используйте синтаксис `--value('literal')` (обратите внимание на кавычки):

```css
/* [!code filename:CSS] */
@utility tab-* {
  tab-size: --value('inherit', 'initial', 'unset');
}
```

This will match utilities like `tab-inherit`, `tab-initial`, and `tab-unset`.

#### Произвольные значения

Чтобы поддерживать произвольные значения, используйте синтаксис `--value([{type}])`  (обратите внимание на квадратные скобки), чтобы сообщить Tailwind, какие типы поддерживаются в качестве произвольного значения:

```css
/* [!code filename:CSS] */
@utility tab-* {
  tab-size: --value([integer]);
}
```

Это будет соответствовать утилитам, таким как `tab-[1]` и `tab-[76]`. Если вы хотите поддерживать любой тип данных, вы можете использовать `--value([*])`.

#### Поддержка тем, чистых и произвольных значений вместе

Все три формы функции `--value()` могут использоваться в правиле в качестве нескольких объявлений, и любые объявления, которые не могут быть разрешены, будут опущены в выводе:

```css
/* [!code filename:CSS] */
@theme {
  --tab-size-github: 8;
}

@utility tab-* {
  tab-size: --value([integer]);
  tab-size: --value(integer);
  /* prettier-ignore */
  tab-size: --value(--tab-size-*);
}
```

Это позволяет обрабатывать значение по-разному в каждом случае, если это необходимо, например, преобразуя целое число в процент:



```css
/* [!code filename:CSS] */
@utility opacity-* {
  opacity: --value([percentage]);
  /* [!code highlight:2] */
  opacity: calc(--value(integer) * 1%);
  /* prettier-ignore */
  opacity: --value(--opacity-*);
}
```

Функция `--value()` также может принимать несколько аргументов и разрешать их слева направо, если вам не нужно обрабатывать возвращаемое значение по-разному в разных случаях:

```css
/* [!code filename:CSS] */
@theme {
  --tab-size-github: 8;
}

@utility tab-* {
  /* [!code highlight:2] */
  /* prettier-ignore */
  tab-size: --value(--tab-size-*, integer, [integer]);
}

@utility opacity-* {
  opacity: calc(--value(integer) * 1%);
  /* [!code highlight:2] */
  /* prettier-ignore */
  opacity: --value(--opacity-*, [percentage]);
}
```

#### Отрицательные значения

Чтобы поддерживать отрицательные значения, зарегистрируйте отдельные положительные и отрицательные утилиты в отдельных объявлениях:

```css
/* [!code filename:CSS] */
@utility inset-* {
  inset: calc(var(--spacing) * --value([percentage], [length]));
}

/* [!code highlight:4] */
@utility -inset-* {
  inset: calc(var(--spacing) * --value([percentage], [length]) * -1);
}
```

#### Модификаторы

Модификаторы обрабатываются с помощью функции `--modifier()`, которая работает точно так же, как функция `--value()`, но оперирует модификатором, если он присутствует:

```css
/* [!code filename:CSS] */
@utility text-* {
  /* prettier-ignore */
  font-size: --value(--text-*, [length]);
  /* [!code highlight:2] */
  /* prettier-ignore */
  line-height: --modifier(--leading-*, [length], [*]);
}
```

Если модификатор не указан, любое объявление, зависящее от модификатора, просто не включается в вывод.

#### Дроби

Для обработки дробей мы полагаемся на тип данных CSS `ratio`. Если это используется с `--value()`, это сигнал Tailwind обрабатывать значение и модификатор как одно значение:

```css
/* [!code filename:CSS] */
@utility aspect-* {
  /* [!code word:ratio, \[ratio\]] */
  /* prettier-ignore */
  aspect-ratio: --value(--aspect-ratio-*, ratio, [ratio]);
}
```

Это будет соответствовать утилитам, таким как `aspect-square`, `aspect-3/4` и `aspect-[7/9]`.

## Добавление пользовательских вариантов

Помимо использования вариантов, поставляемых с Tailwind, вы также можете добавлять свои собственные варианты с помощью директивы `@custom-variant`:

```css
@custom-variant theme-midnight {
  &:where([data-theme="midnight"] *) {
    @slot;
  }
}
```

Теперь вы можете использовать вариант `theme-midnight:<utility>` в своем HTML:

```html
<!-- [!code classes:theme-midnight:bg-black] -->
<html data-theme="midnight">
  <button class="theme-midnight:bg-black ..."></button>
</html>
```

Вы можете создавать варианты, используя сокращенный синтаксис, когда вложенность не требуется:

```css
@custom-variant theme-midnight (&:where([data-theme="midnight"] *));
```

When a custom variant has multiple rules, they can be nested within each other:

```css
@custom-variant any-hover {
  @media (any-hover: hover) {
    &:hover {
      @slot;
    }
  }
}
```
